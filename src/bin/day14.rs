use std::collections::HashMap;

use advent2024::{
    advent_main, all_lines,
    grid::GridCharWorld,
    multidim::{Dir, ManhattanDir, Position},
    Part,
};
use hash_histogram::HashHistogram;
use pancurses::{endwin, initscr, noecho, Input};

fn main() -> anyhow::Result<()> {
    advent_main(|filename, part, _| {
        let robots = all_lines(filename)?.map(Robot::new).collect::<Vec<_>>();
        let (width, height) = if filename.contains("ex") {
            (11, 7)
        } else {
            (101, 103)
        };
        let dimensions = Position::from((width, height));
        match part {
            Part::One => part1(robots, dimensions),
            Part::Two => visualize(robots, dimensions),
        }
        Ok(())
    })
}

fn part1(mut robots: Vec<Robot>, dimensions: Position) {
    for _ in 0..100 {
        advance_all_robots(&mut robots, dimensions);
    }
    let counts = robots
        .iter()
        .filter_map(|r| r.dir_from_center(dimensions))
        .filter(|d| ManhattanDir::try_from(*d).is_err())
        .collect::<HashHistogram<Dir>>();
    let total = counts.counts().product::<usize>();
    println!("{total}");
}

fn part2(mut robots: Vec<Robot>, dimensions: Position) {
    let mut seconds = 0;
    let mut seen = HashMap::new();
    loop {
        let central = central_column_count(&robots, dimensions);
        if central > 10 {
            println!("{central} {seconds}s");
        }
        advance_all_robots(&mut robots, dimensions);
        seconds += 1;
        match seen.get(&robots) {
            None => {
                seen.insert(robots.clone(), seconds);
            }
            Some(s) => {
                println!("Repeated at {s}");
                break;
            }
        }
    }
    println!("{seconds}");
}

fn advance_all_robots(robots: &mut Vec<Robot>, dimensions: Position) {
    for r in robots.iter_mut() {
        r.advance(dimensions);
    }
}

fn retreat_all_robots(robots: &mut Vec<Robot>, dimensions: Position) {
    for r in robots.iter_mut() {
        r.retreat(dimensions);
    }
}

fn central_column_count(robots: &Vec<Robot>, dimensions: Position) -> usize {
    let map = render(robots, dimensions);
    let x = dimensions[0] / 2;
    (0..dimensions[1]).filter(|y| map.get(x as usize, *y as usize) == Some('O')).count()
}

// Curses tutorial generated by Perplexity.ai:
// https://www.perplexity.ai/search/write-a-tutorial-on-using-curs-0oe7KdRIRaa7qoqtnL.S_A
fn visualize(mut robots: Vec<Robot>, dimensions: Position) {
    let mut seen = HashMap::new();
    let mut seconds = 0;
    let window = initscr();
    window.keypad(true);
    noecho();

    loop {
        window.clear();
        match seen.get(&robots) {
            None => {
                seen.insert(robots.clone(), seconds);
            }
            Some(s) => {
                if *s > seconds {
                    window.addstr(format!("REPEAT: {s}s\n"));
                }
            }
        }
        window.addstr(format!("time: {seconds}s\n"));
        window.addstr(format!("{}", render(&robots, dimensions)));
        match window.getch() {
            Some(Input::Character(c)) => match c {
                'a' | 'f' => {
                    seconds += 1;
                    advance_all_robots(&mut robots, dimensions);
                }
                'd' | 'r' | 'b' => {
                    seconds -= 1;
                    retreat_all_robots(&mut robots, dimensions);
                }
                'c' => {
                    loop {
                        seconds += 1;
                        advance_all_robots(&mut robots, dimensions);
                        if central_column_count(&robots, dimensions) > 10 {break;}
                    }
                }
                'q' => break,
                _ => {}
            },
            Some(Input::KeyDC) => break,
            _ => (),
        }
    }

    endwin();
}

fn render(robots: &Vec<Robot>, dimensions: Position) -> GridCharWorld {
    let mut image = GridCharWorld::new(dimensions[0] as usize, dimensions[1] as usize, '.');
    for robot in robots.iter() {
        image.update(robot.p, 'O');
    }
    image
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
struct Robot {
    p: Position,
    v: Position,
}

impl Robot {
    fn new(line: String) -> Self {
        let re = regex::Regex::new(r"-?\d+").unwrap();
        let mut iter = re
            .find_iter(line.as_str())
            .map(|n| n.as_str().parse::<isize>().unwrap());
        let p = Position::from((iter.next().unwrap(), iter.next().unwrap()));
        let v = Position::from((iter.next().unwrap(), iter.next().unwrap()));
        Self { p, v }
    }

    fn advance(&mut self, dimensions: Position) {
        self.p = (self.p + self.v) % dimensions;
    }

    fn retreat(&mut self, dimensions: Position) {
        self.p = (self.p - self.v) % dimensions;
    }

    fn dir_from_center(&self, dimensions: Position) -> Option<Dir> {
        let center = dimensions / 2;
        let offset = self.p - center;
        if offset[0] == 0 {
            if offset[1] == 0 {
                None
            } else if offset[1] < 0 {
                Some(Dir::N)
            } else {
                Some(Dir::S)
            }
        } else if offset[1] == 0 {
            if offset[0] < 0 {
                Some(Dir::W)
            } else {
                Some(Dir::E)
            }
        } else if offset[0] < 0 {
            if offset[1] < 0 {
                Some(Dir::Nw)
            } else {
                Some(Dir::Sw)
            }
        } else {
            if offset[1] < 0 {
                Some(Dir::Ne)
            } else {
                Some(Dir::Se)
            }
        }
    }
}
